package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"log/slog"

	"github.com/ericbutera/amalgam/internal/tasks"
	pb "github.com/ericbutera/amalgam/pkg/feeds/v1"
	"github.com/ericbutera/amalgam/services/graph/graph/dataloaders"
	"github.com/ericbutera/amalgam/services/graph/graph/model"
	errHelper "github.com/ericbutera/amalgam/services/graph/internal/errors"
	"github.com/ericbutera/amalgam/services/graph/internal/middleware"
	"github.com/samber/lo"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// AddFeed is the resolver for the addFeed field.
func (r *mutationResolver) AddFeed(ctx context.Context, url string, name string) (*model.AddResponse, error) {
	// Note: this should use a Feed Task instead of performing the verification directly. ref: https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/ch08.html

	args := []any{
		url,
		middleware.GetUserID(ctx), // TODO: r.auth.GetUserID(ctx)
	}
	result, err := r.tasks.Workflow(ctx, tasks.TaskFetchFeeds, args /*middleware.GetUserID(ctx)*/) // TODO: r.auth.GetUserID(ctx)
	if err != nil {
		slog.ErrorContext(ctx, "failed to start feed task", "error", err)
		return nil, status.Errorf(codes.Internal, "failed to start feed task")
	}
	// return &model.FeedTaskResponse{
	// 	TaskID: result.ID,
	// }, nil
	return &model.AddResponse{
		JobID: result.ID,
	}, nil
}

// UpdateFeed is the resolver for the updateFeed field.
func (r *mutationResolver) UpdateFeed(ctx context.Context, id string, url *string, name *string) (*model.UpdateResponse, error) {
	_, err := r.rpcClient.UpdateFeed(ctx, &pb.UpdateFeedRequest{
		Feed: &pb.UpdateFeedRequest_Feed{
			Id:   id,
			Url:  lo.FromPtr(url),
			Name: lo.FromPtr(name),
		},
	})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to update feed")
	}
	// TODO: converter.ServiceToGraphFeed
	// TODO: revisit returning id (rpc returns empty)
	return &model.UpdateResponse{
		ID: id,
	}, nil
}

// FeedTask is the resolver for the feedTask field.
func (r *mutationResolver) FeedTask(ctx context.Context, task model.TaskType) (*model.FeedTaskResponse, error) {
	var t tasks.TaskType
	switch task {
	case model.TaskTypeGenerateFeeds:
		t = tasks.TaskGenerateFeeds
	case model.TaskTypeRefreshFeeds:
		t = tasks.TaskFetchFeeds
	default:
		return nil, status.Errorf(codes.InvalidArgument, "invalid task type")
	}

	var args []any
	result, err := r.tasks.Workflow(ctx, t, args /*middleware.GetUserID(ctx)*/) // TODO: r.auth.GetUserID(ctx)
	if err != nil {
		slog.ErrorContext(ctx, "failed to start feed task", "error", err)
		return nil, status.Errorf(codes.Internal, "failed to start feed task")
	}
	return &model.FeedTaskResponse{
		TaskID: result.ID,
	}, nil
}

// MarkArticleRead is the resolver for the markArticleRead field.
func (r *mutationResolver) MarkArticleRead(ctx context.Context, id string) (*model.UpdateResponse, error) {
	_, err := r.rpcClient.MarkArticleAsRead(ctx, &pb.MarkArticleAsReadRequest{
		User:      &pb.User{Id: middleware.GetUserID(ctx)}, // TODO: r.auth.GetUserID(ctx)
		ArticleId: id,
	})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to mark article read")
	}
	return &model.UpdateResponse{}, nil
}

// Feeds is the resolver for the feeds field.
func (r *queryResolver) Feeds(ctx context.Context) (*model.FeedResponse, error) {
	// TODO: dataloader for GetFeed + GetUserFeed
	resp, err := r.rpcClient.ListUserFeeds(ctx, &pb.ListUserFeedsRequest{
		User: &pb.User{Id: middleware.GetUserID(ctx)}, // TODO: r.auth.GetUserID(ctx)
	})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to list feeds")
	}
	var feeds []*model.Feed
	for _, feed := range resp.GetFeeds() {
		feeds = append(feeds, r.converter.ProtoUserFeedToGraphUserFeed(feed))
	}
	return &model.FeedResponse{
		Feeds: feeds,
	}, nil
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, id string) (*model.Feed, error) {
	resp, err := r.rpcClient.GetUserFeed(ctx, &pb.GetUserFeedRequest{
		UserId: middleware.GetUserID(ctx), // TODO: r.auth.GetUserID(ctx)
		FeedId: id,
	})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to get feed")
	}
	return r.converter.ProtoUserFeedToGraphUserFeed(resp.GetFeed()), nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, feedID string, options *model.ListOptions) (*model.ArticlesResponse, error) {
	// TODO: validation https://gqlgen.com/recipes/modelgen-hook/
	resp, err := r.rpcClient.ListArticles(ctx, &pb.ListArticlesRequest{
		FeedId:  feedID,
		Options: r.converter.GraphToProtoListOptions(options),
	})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to list articles")
	}

	ids := lo.Map(resp.GetArticles(), func(article *pb.Article, _ int) string { return article.GetId() })

	var articles []*model.Article
	for _, article := range resp.GetArticles() {
		articles = append(articles, r.converter.ProtoToGraphArticle(article))
	}

	// TODO: i don't like how this is composed at the moment. i also am not sure a better way
	// to handle this.
	// concerns:
	// - dataloader isn't injected
	// - multiple loops over dataset (get ids, article conversion, loop articles to merge UserArticle)
	// - unit test needs to mock RPC call inside NewUserArticleLoader which isn't ideal
	// - general: too many lines of code

	/*
		it would be nice to have something like this example, where "it just works" instead of go's insistence on error & nil checks everywhere
		const UserType = new GraphQLObjectType({
		name: 'User',
		fields: () => ({
			name: { type: GraphQLString },
			bestFriend: {
			type: UserType,
			resolve: user => userLoader.load(user.bestFriendID),
			},
			friends: {
			args: {
				first: { type: GraphQLInt },
			},
			type: new GraphQLList(UserType),
			resolve: async (user, { first }) => {
				const rows = await queryLoader.load([
				'SELECT toID FROM friends WHERE fromID=? LIMIT ?',
				user.id,
				first,
				]);
				return rows.map(row => userLoader.load(row.toID));
			},
			},
		}),
		});
	*/

	userID := middleware.GetUserID(ctx) // TODO: r.auth.GetUserID(ctx)
	res, errs := dataloaders.NewUserArticleLoader(r.rpcClient, userID).
		LoadMany(ctx, ids)()
	if errs != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, errs[0], "failed to load user article metadata")
	}

	for i, userArticle := range res {
		articles[i].UserArticle = r.converter.ProtoToGraphUserArticle(userArticle)
	}

	return &model.ArticlesResponse{
		Articles: articles,
		Cursor:   r.converter.ProtoToGraphCursor(resp.GetCursor()),
	}, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	resp, err := r.rpcClient.GetArticle(ctx, &pb.GetArticleRequest{Id: id})
	if err != nil {
		return nil, errHelper.HandleGrpcErrors(ctx, err, "failed to get article")
	}
	article := r.converter.ProtoToGraphArticle(resp.GetArticle())

	userID := middleware.GetUserID(ctx) // TODO: r.auth.GetUserID(ctx)
	res, _ := dataloaders.NewUserArticleLoader(r.rpcClient, userID).
		LoadMany(ctx, []string{article.ID})()

	if res != nil {
		if ua := res[0]; ua != nil {
			article.UserArticle = r.converter.ProtoToGraphUserArticle(ua)
		}
	}

	return article, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
