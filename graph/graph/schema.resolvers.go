package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"

	pb "github.com/ericbutera/amalgam/pkg/rpc/proto"
	rpc "github.com/ericbutera/amalgam/rpc/pkg/client"

	"github.com/ericbutera/amalgam/graph/graph/model"
	rest "github.com/ericbutera/amalgam/pkg/client"
	"github.com/ericbutera/amalgam/pkg/convert"
	"github.com/samber/lo"
)

func (r *mutationResolver) AddFeed(ctx context.Context, url string, name string) (*model.Feed, error) {
	req := rest.ServerCreateFeedRequest{
		Feed: &rest.ServerCreateFeed{
			Url: url,
			// TODO: support name `Name: &name,`
		},
	}
	resp, _, err := r.apiClient.DefaultAPI.FeedsPost(ctx).Request(req).Execute()
	if err != nil {
		return nil, err
	}
	feed := model.Feed{
		ID:   fmt.Sprintf("%d", resp.Feed.Id),
		URL:  resp.Feed.Url,
		Name: lo.FromPtr(resp.Feed.Name),
	}
	return &feed, nil
}

func (r *mutationResolver) UpdateFeed(ctx context.Context, id string, url *string, name *string) (*model.Feed, error) {
	uid, err := convert.ParseUInt(id)
	if err != nil {
		return nil, err
	}
	req := rest.ServerUpdateFeedRequest{
		Feed: &rest.ServerUpdateFeed{
			Url: lo.FromPtr(url),
			// TODO: support name `Name: &name,`
		},
	}
	resp, _, err := r.apiClient.DefaultAPI.FeedsIdPut(ctx, int32(uid)).Request(req).Execute()
	if err != nil {
		return nil, err
	}
	feed := model.Feed{
		ID:   fmt.Sprintf("%d", resp.Feed.Id),
		URL:  resp.Feed.Url,
		Name: lo.FromPtr(resp.Feed.Name),
	}
	return &feed, nil
}

func (r *queryResolver) Feeds(ctx context.Context) ([]*model.Feed, error) {
	var feeds []*model.Feed
	/*
		resp, _, err := r.apiClient.DefaultAPI.FeedsGet(ctx).Execute()
		if err != nil {
			return nil, err
		}
		for _, feed := range resp.Feeds {
			// TODO: mapstructure!
			feeds = append(feeds, &model.Feed{
				ID:   fmt.Sprintf("%d", feed.Id),
				URL:  feed.Url,
				Name: lo.FromPtr(feed.Name),
			})
		}
	*/
	c, err := rpc.NewClient("localhost:50055") // TODO: env
	if err != nil {
		return nil, err
	}
	defer c.Conn.Close()

	res, err := c.Client.ListFeeds(ctx, &pb.Empty{})
	if err != nil {
		return nil, err
	}
	for _, feed := range res.Feeds {
		// TODO mapper
		feeds = append(feeds, &model.Feed{
			ID:   fmt.Sprintf("%d", feed.Id),
			URL:  feed.Url,
			Name: feed.Name,
		})
	}

	return feeds, nil
}

func (r *queryResolver) Feed(ctx context.Context, id string) (*model.Feed, error) {
	uid, err := convert.ParseUInt(id)
	if err != nil {
		return nil, err
	}
	resp, _, err := r.apiClient.DefaultAPI.FeedsIdGet(ctx, int32(uid)).Execute()
	if err != nil {
		return nil, err
	}
	// convert resp.Feed into model.Feed
	// note: both have json tags which might be usable for conversion (instead of mapstructure)
	feed := model.Feed{
		ID:   id,
		URL:  resp.Feed.Url,
		Name: lo.FromPtr(resp.Feed.Name),
	}
	return &feed, nil
}

func (r *queryResolver) Articles(ctx context.Context, feedID string) ([]*model.Article, error) {
	uid, err := convert.ParseUInt(feedID)
	if err != nil {
		return nil, err
	}
	resp, _, err := r.apiClient.DefaultAPI.FeedsIdArticlesGet(ctx, int32(uid)).Execute()
	if err != nil {
		return nil, err
	}
	var articles []*model.Article
	for _, article := range resp.Articles {
		articles = append(articles, &model.Article{
			ID:      string(article.Id),
			Title:   lo.FromPtr(article.Title),
			Content: lo.FromPtr(article.Content),
		})
	}
	return articles, nil
}

func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	uid, err := convert.ParseUInt(id)
	if err != nil {
		return nil, err
	}
	resp, _, err := r.apiClient.DefaultAPI.ArticlesIdGet(ctx, int32(uid)).Execute()
	if err != nil {
		return nil, err
	}
	// TODO: auto map fields
	article := model.Article{
		ID:      id,
		Title:   lo.FromPtr(resp.Article.Title),
		Content: lo.FromPtr(resp.Article.Content),
	}
	return &article, nil
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }
func (r *Resolver) Query() QueryResolver       { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
